# typed: strong

module NextbillionSDK
  module Models
    module Fleetify
      class RouteCreateParams < NextbillionSDK::Internal::Type::BaseModel
        extend NextbillionSDK::Internal::Type::RequestParameters::Converter
        include NextbillionSDK::Internal::Type::RequestParameters

        OrHash =
          T.type_alias do
            T.any(
              NextbillionSDK::Fleetify::RouteCreateParams,
              NextbillionSDK::Internal::AnyHash
            )
          end

        # A key is a unique identifier that is required to authenticate a request to the
        # API.
        sig { returns(String) }
        attr_accessor :key

        # Specify the e-mail address of the driver who should receive the route. The
        # e-mail address must be registered in
        # [NextBillion.ai Cloud Console](https://console.nextbillion.ai/).
        sig { returns(String) }
        attr_accessor :driver_email

        # An array of objects to collect the details about the intermediate steps in the
        # route to be dispatched. Each object corresponds to a single step. The array must
        # begin with a start-type step and end with an end-type step, to form a valid
        # route.
        sig do
          returns(T::Array[NextbillionSDK::Fleetify::Routes::RouteStepsRequest])
        end
        attr_accessor :steps

        # Specify the total distance, in meters, for an informative display in Driver's
        # app. The distance specified here has no effect on the actual route that the
        # service generates.
        sig { returns(T.nilable(Integer)) }
        attr_reader :distance

        sig { params(distance: Integer).void }
        attr_writer :distance

        # Specify the ID of the document template that should be used to collect proof of
        # completion for all steps in the route. In order to complete each route step, the
        # driver will need to submit a form generated by the rules defined in the given
        # document template. Use the
        # [Documents API](https://docs.nextbillion.ai/docs/dispatches/documents-api) to
        # create, read and manage document templates.
        #
        # Please note that the document template ID assigned to a route does not apply to
        # following step types - `start`, `end`, `break`, `layover`.
        sig { returns(T.nilable(String)) }
        attr_reader :document_template_id

        sig { params(document_template_id: String).void }
        attr_writer :document_template_id

        # Specify the Route Optimization request ID. When this ID is provided, all other
        # fields will be ignored (including the required fields) and the route
        # optimization result will be used to form the routes and corresponding steps.
        #
        # Please note that:
        #
        # - The driver's email ID must be provided in input `vehicle.metadata` as
        #   `user_email` such that the route optimization result must contain a valid
        #   driver email, step's arrival time, etc., to make a successful dispatch.
        # - Document Template for collecting proof of delivery or completion can not be
        #   specified when using this field to dispatch a route.
        # - In case of an error at any part among the routes, the API will immediately
        #   return the error with the index of the specific route or route step.
        # - On a successful dispatch, the API returns the last route, if there are many,
        #   in the response payload.
        sig { returns(T.nilable(String)) }
        attr_reader :ro_request_id

        sig { params(ro_request_id: String).void }
        attr_writer :ro_request_id

        # The `routing` object allows defining the routing characteristics that should be
        # used to generate a route when the Driver uses the in-app navigation. Only `car`
        # mode is supported currently.
        sig do
          returns(
            T.nilable(NextbillionSDK::Fleetify::RouteCreateParams::Routing)
          )
        end
        attr_reader :routing

        sig do
          params(
            routing:
              NextbillionSDK::Fleetify::RouteCreateParams::Routing::OrHash
          ).void
        end
        attr_writer :routing

        sig do
          params(
            key: String,
            driver_email: String,
            steps:
              T::Array[
                NextbillionSDK::Fleetify::Routes::RouteStepsRequest::OrHash
              ],
            distance: Integer,
            document_template_id: String,
            ro_request_id: String,
            routing:
              NextbillionSDK::Fleetify::RouteCreateParams::Routing::OrHash,
            request_options: NextbillionSDK::RequestOptions::OrHash
          ).returns(T.attached_class)
        end
        def self.new(
          # A key is a unique identifier that is required to authenticate a request to the
          # API.
          key:,
          # Specify the e-mail address of the driver who should receive the route. The
          # e-mail address must be registered in
          # [NextBillion.ai Cloud Console](https://console.nextbillion.ai/).
          driver_email:,
          # An array of objects to collect the details about the intermediate steps in the
          # route to be dispatched. Each object corresponds to a single step. The array must
          # begin with a start-type step and end with an end-type step, to form a valid
          # route.
          steps:,
          # Specify the total distance, in meters, for an informative display in Driver's
          # app. The distance specified here has no effect on the actual route that the
          # service generates.
          distance: nil,
          # Specify the ID of the document template that should be used to collect proof of
          # completion for all steps in the route. In order to complete each route step, the
          # driver will need to submit a form generated by the rules defined in the given
          # document template. Use the
          # [Documents API](https://docs.nextbillion.ai/docs/dispatches/documents-api) to
          # create, read and manage document templates.
          #
          # Please note that the document template ID assigned to a route does not apply to
          # following step types - `start`, `end`, `break`, `layover`.
          document_template_id: nil,
          # Specify the Route Optimization request ID. When this ID is provided, all other
          # fields will be ignored (including the required fields) and the route
          # optimization result will be used to form the routes and corresponding steps.
          #
          # Please note that:
          #
          # - The driver's email ID must be provided in input `vehicle.metadata` as
          #   `user_email` such that the route optimization result must contain a valid
          #   driver email, step's arrival time, etc., to make a successful dispatch.
          # - Document Template for collecting proof of delivery or completion can not be
          #   specified when using this field to dispatch a route.
          # - In case of an error at any part among the routes, the API will immediately
          #   return the error with the index of the specific route or route step.
          # - On a successful dispatch, the API returns the last route, if there are many,
          #   in the response payload.
          ro_request_id: nil,
          # The `routing` object allows defining the routing characteristics that should be
          # used to generate a route when the Driver uses the in-app navigation. Only `car`
          # mode is supported currently.
          routing: nil,
          request_options: {}
        )
        end

        sig do
          override.returns(
            {
              key: String,
              driver_email: String,
              steps:
                T::Array[NextbillionSDK::Fleetify::Routes::RouteStepsRequest],
              distance: Integer,
              document_template_id: String,
              ro_request_id: String,
              routing: NextbillionSDK::Fleetify::RouteCreateParams::Routing,
              request_options: NextbillionSDK::RequestOptions
            }
          )
        end
        def to_hash
        end

        class Routing < NextbillionSDK::Internal::Type::BaseModel
          OrHash =
            T.type_alias do
              T.any(
                NextbillionSDK::Fleetify::RouteCreateParams::Routing,
                NextbillionSDK::Internal::AnyHash
              )
            end

          # Specify the side of the road from which the route should approach the step
          # location. When set to `unrestricted` a route can arrive at the step location
          # from either side of the road and when set to `curb` the route will arrive at the
          # step location only from the driving side of the region. Use a semi-colon `;` to
          # specify approach configurations for multiple steps.
          sig do
            returns(
              T.nilable(
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Approaches::OrSymbol
              )
            )
          end
          attr_reader :approaches

          sig do
            params(
              approaches:
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Approaches::OrSymbol
            ).void
          end
          attr_writer :approaches

          # Setting this will ensure the generated route avoids the object(s) specified in
          # the input. Multiple values should be separated by a pipe (|). If `none` is
          # provided along with other values, an error is returned as a valid route is not
          # feasible.
          sig do
            returns(
              T.nilable(
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::OrSymbol
              )
            )
          end
          attr_reader :avoid

          sig do
            params(
              avoid:
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::OrSymbol
            ).void
          end
          attr_writer :avoid

          # Specify the type of hazardous material being carried and the dispatch service
          # will avoid roads which are not suitable for the type of goods specified.
          # Multiple values can be separated using a pipe operator `|` .
          #
          # Please note that this parameter is effective only when `mode=truck`.
          sig do
            returns(
              T.nilable(
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::HazmatType::OrSymbol
              )
            )
          end
          attr_reader :hazmat_type

          sig do
            params(
              hazmat_type:
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::HazmatType::OrSymbol
            ).void
          end
          attr_writer :hazmat_type

          # Specify the driving mode that the service should use to determine a route
          sig do
            returns(
              T.nilable(
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Mode::OrSymbol
              )
            )
          end
          attr_reader :mode

          sig do
            params(
              mode:
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Mode::OrSymbol
            ).void
          end
          attr_writer :mode

          # Specify the total load per axle (including the weight of trailers and shipped
          # goods) of the truck, in tonnes. When specified, the dispatched route uses only
          # those roads which can be used by a truck to carry the specified load per axle.
          #
          # Please note this parameter is effective only when `mode=truck`.
          sig { returns(T.nilable(Integer)) }
          attr_reader :truck_axle_load

          sig { params(truck_axle_load: Integer).void }
          attr_writer :truck_axle_load

          # Specify the dimensions of a truck, in centimeters (cm), in the format of
          # <height, width, length>. When specified, the dispatched route uses only those
          # roads which allow trucks with specified dimensions.
          #
          # Please note this parameter is effective only when `mode=truck`. Also, the
          # maximum dimensions that can be specified are as follows:
          #
          # Height = 1000 cm
          # Width = 5000 cm
          # Length = 5000 cm
          sig { returns(T.nilable(String)) }
          attr_reader :truck_size

          sig { params(truck_size: String).void }
          attr_writer :truck_size

          # Specify the weight of the truck, including trailers and shipped goods, in
          # kilograms (kg). When specified, the dispatched route uses only those roads which
          # allow trucks with specified weight.
          #
          # Please note this parameter is effective only when `mode=truck`. Also, the
          # maximum weight that can be specified for a truck is 100,000 kgs.
          sig { returns(T.nilable(Integer)) }
          attr_reader :truck_weight

          sig { params(truck_weight: Integer).void }
          attr_writer :truck_weight

          # The `routing` object allows defining the routing characteristics that should be
          # used to generate a route when the Driver uses the in-app navigation. Only `car`
          # mode is supported currently.
          sig do
            params(
              approaches:
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Approaches::OrSymbol,
              avoid:
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::OrSymbol,
              hazmat_type:
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::HazmatType::OrSymbol,
              mode:
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Mode::OrSymbol,
              truck_axle_load: Integer,
              truck_size: String,
              truck_weight: Integer
            ).returns(T.attached_class)
          end
          def self.new(
            # Specify the side of the road from which the route should approach the step
            # location. When set to `unrestricted` a route can arrive at the step location
            # from either side of the road and when set to `curb` the route will arrive at the
            # step location only from the driving side of the region. Use a semi-colon `;` to
            # specify approach configurations for multiple steps.
            approaches: nil,
            # Setting this will ensure the generated route avoids the object(s) specified in
            # the input. Multiple values should be separated by a pipe (|). If `none` is
            # provided along with other values, an error is returned as a valid route is not
            # feasible.
            avoid: nil,
            # Specify the type of hazardous material being carried and the dispatch service
            # will avoid roads which are not suitable for the type of goods specified.
            # Multiple values can be separated using a pipe operator `|` .
            #
            # Please note that this parameter is effective only when `mode=truck`.
            hazmat_type: nil,
            # Specify the driving mode that the service should use to determine a route
            mode: nil,
            # Specify the total load per axle (including the weight of trailers and shipped
            # goods) of the truck, in tonnes. When specified, the dispatched route uses only
            # those roads which can be used by a truck to carry the specified load per axle.
            #
            # Please note this parameter is effective only when `mode=truck`.
            truck_axle_load: nil,
            # Specify the dimensions of a truck, in centimeters (cm), in the format of
            # <height, width, length>. When specified, the dispatched route uses only those
            # roads which allow trucks with specified dimensions.
            #
            # Please note this parameter is effective only when `mode=truck`. Also, the
            # maximum dimensions that can be specified are as follows:
            #
            # Height = 1000 cm
            # Width = 5000 cm
            # Length = 5000 cm
            truck_size: nil,
            # Specify the weight of the truck, including trailers and shipped goods, in
            # kilograms (kg). When specified, the dispatched route uses only those roads which
            # allow trucks with specified weight.
            #
            # Please note this parameter is effective only when `mode=truck`. Also, the
            # maximum weight that can be specified for a truck is 100,000 kgs.
            truck_weight: nil
          )
          end

          sig do
            override.returns(
              {
                approaches:
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::Approaches::OrSymbol,
                avoid:
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::OrSymbol,
                hazmat_type:
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::HazmatType::OrSymbol,
                mode:
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::Mode::OrSymbol,
                truck_axle_load: Integer,
                truck_size: String,
                truck_weight: Integer
              }
            )
          end
          def to_hash
          end

          # Specify the side of the road from which the route should approach the step
          # location. When set to `unrestricted` a route can arrive at the step location
          # from either side of the road and when set to `curb` the route will arrive at the
          # step location only from the driving side of the region. Use a semi-colon `;` to
          # specify approach configurations for multiple steps.
          module Approaches
            extend NextbillionSDK::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::Approaches
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            UNRESTRICTED =
              T.let(
                :"`unrestricted`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Approaches::TaggedSymbol
              )
            CURB =
              T.let(
                :"`curb`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Approaches::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::Approaches::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end

          # Setting this will ensure the generated route avoids the object(s) specified in
          # the input. Multiple values should be separated by a pipe (|). If `none` is
          # provided along with other values, an error is returned as a valid route is not
          # feasible.
          module Avoid
            extend NextbillionSDK::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            TOLL =
              T.let(
                :"`toll`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::TaggedSymbol
              )
            HIGHWAY =
              T.let(
                :"`highway`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::TaggedSymbol
              )
            FERRY =
              T.let(
                :"`ferry`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::TaggedSymbol
              )
            SHARP_TURN =
              T.let(
                :"`sharp_turn`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::TaggedSymbol
              )
            UTURN =
              T.let(
                :"`uturn`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::TaggedSymbol
              )
            LEFT_TURN =
              T.let(
                :"`left_turn`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::TaggedSymbol
              )
            RIGHT_TURN =
              T.let(
                :"`right_turn`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::TaggedSymbol
              )
            SERVICE_ROAD =
              T.let(
                :"`service_road`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::TaggedSymbol
              )
            NONE =
              T.let(
                :"`none`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::Avoid::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end

          # Specify the type of hazardous material being carried and the dispatch service
          # will avoid roads which are not suitable for the type of goods specified.
          # Multiple values can be separated using a pipe operator `|` .
          #
          # Please note that this parameter is effective only when `mode=truck`.
          module HazmatType
            extend NextbillionSDK::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::HazmatType
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            GENERAL =
              T.let(
                :"`general`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::HazmatType::TaggedSymbol
              )
            CIRCUMSTANTIAL =
              T.let(
                :"`circumstantial`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::HazmatType::TaggedSymbol
              )
            EXPLOSIVE =
              T.let(
                :"`explosive`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::HazmatType::TaggedSymbol
              )
            HARMFUL_TO_WATER =
              T.let(
                :"`harmful_to_water`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::HazmatType::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::HazmatType::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end

          # Specify the driving mode that the service should use to determine a route
          module Mode
            extend NextbillionSDK::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::Mode
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            CAR =
              T.let(
                :"`car`",
                NextbillionSDK::Fleetify::RouteCreateParams::Routing::Mode::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  NextbillionSDK::Fleetify::RouteCreateParams::Routing::Mode::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end
        end
      end
    end
  end
end
